<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"><title>JBoss Tools Aggregated Feed</title><link rel="alternate" href="http://tools.jboss.org" /><subtitle>JBoss Tools Aggregated Feed</subtitle><dc:creator>JBoss Tools</dc:creator><entry><title>How to configure SOAP web services with Apache Camel</title><link rel="alternate" href="https://developers.redhat.com/articles/2023/03/28/how-configure-soap-web-services-apache-camel" /><author><name>Michael Thirion</name></author><id>312bb7ef-e872-4a11-9b54-6ff82cc74b8c</id><updated>2023-03-28T07:00:00Z</updated><published>2023-03-28T07:00:00Z</published><summary type="html">&lt;p&gt;This article demonstrates how to configure Simple Object Access Protocol (SOAP) web services with the Red Hat build of Apache Camel, &lt;a href="https://developers.redhat.com/products/quarkus/overview"&gt;Quarkus&lt;/a&gt; version. In Apache Camel version 3, the support for the SOAP protocol is still provided by the CXF framework. Therefore, on Quarkus, we will be relying on the camel-quarkus-cxf-soap extension.&lt;/p&gt; &lt;h2&gt;A common REST to SOAP transformation use case&lt;/h2&gt; &lt;p&gt;With the CXF runtime, there is a distinction to make between a SOAP service and the client of a SOAP service.&lt;/p&gt; &lt;p&gt;Let's use a very common use case to demonstrate those two parts distinctively. Let's imagine a legacy SOAP web service backend that we want to expose behind a REST endpoint (Figure 1).&lt;/p&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/arch_9.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/arch_9.png?itok=xuf29oUi" width="497" height="122" alt="Use case architecture." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 1. Use case architecture.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;p&gt;You can find the source code of the two applications developed for that purpose on this &lt;a href="https://github.com/mthirion/camel-quarkus-cxf-soap-and-ws-security"&gt;GitHub page&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;The SOAP web service backend is represented by a mock implementation of a publicly available definition, sourced from &lt;a href="https://www.herongyang.com/1000230_Live_Examples_of_Web_Services.html"&gt;herongyang.com&lt;/a&gt;. The web service at play is Registration SOAP 1.1.&lt;/p&gt; &lt;p&gt;For both the CXF client and server development, the first step is to generate the &lt;a href="http://developers.redhat.com/topics/java"&gt;Java&lt;/a&gt; objects corresponding to the WSDL elements. This can be done with the cxf-codegen-plugin Maven plugin, whose wsdl2java task generates Java representations of the soap request and response payloads, as well as the service interface and its implementation (PortType).&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ tree target/generated-sources/cxf target/generated-sources/cxf └── https └── www_herongyang_com └── service ├── ObjectFactory.java ├── package-info.java ├── RegistrationPortType.java ├── RegistrationRequest.java ├── RegistrationResponse.java └── RegistrationService.java&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Configuring a Camel CXF SOAP server&lt;/h2&gt; &lt;p&gt;Let's now dig into the core part of the configuration.&lt;/p&gt; &lt;p&gt;On the server side, there is a Camel route that starts with the following line:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;from("cxf:registration?serviceClass=https.www_herongyang_com.service.RegistrationPortType")&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The second element of the endpoint URI is the name of a CxfEndpoint Java bean that contains the configuration of the CXF endpoint such as the service name, endpoint name, and exposed URL.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;@Named("registration") @ApplicationScoped public class SoapServiceBean extends CxfEndpoint { public SoapServiceBean() { super(); try { this.configure(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } private void configure() throws ClassNotFoundException { QName serviceQname = new QName("https://www.herongyang.com/Service/", "registrationService"); // From WSDL :: &lt;wsdl:service name="registrationService"&gt; this.setServiceNameAsQName(serviceQname); QName endpointQname = new QName("https://www.herongyang.com/Service/", "registrationPort"); // From WSDL :: &lt;wsdl:port name="registrationPort"&gt; this.setEndpointNameAsQName(endpointQname); this.setAddress("http://localhost:8055/soap/registration"); // Exposed address with the /soap root context defined in application.properties } }&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;That's it!&lt;/p&gt; &lt;p&gt;With that configuration, the web service should be available at &lt;code&gt;http://localhost:8085/soap/registration&lt;/code&gt;. We can test it with SOAPUI using the following request:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-xml"&gt;&lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ser="https://www.herongyang.com/Service/"&gt; &lt;&lt;soap:Header/&gt;&gt; &lt;&lt;soap:Body&gt;&gt; &lt;ser:RegistrationRequest date="now" event="123"&gt; &lt;Guest&gt;John&lt;/Guest&gt; &lt;/ser:RegistrationRequest&gt; &lt;/soap:Body&gt; &lt;/soap:Envelope&gt;&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Configuring a Camel CXF SOAP client&lt;/h2&gt; &lt;p&gt;In the case of a client, the CxfEndpoint bean is not required. The URI can directly embed the target address as follows:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt; .to("cxf:http://localhost:8055/soap/registration?serviceClass=https.www_herongyang_com.service.RegistrationPortType")&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;You can attempt an end-to-end test with the following command:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;curl -H "Content-Type: application/json" -XPOST http://localhost:8050/api/registration -d '{"event":"123","guest":"john"}'&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Applying WS-Security or other SOAP features&lt;/h2&gt; &lt;p&gt;The CXF framework still builds on the concept of interceptors and interceptors chain. On Quarkus, interceptors are injected into the CXF runtime in Java.  The hook to the CXF runtime is the cxfConfigurer option of the URI endpoint.&lt;/p&gt; &lt;p&gt;For the server, the endpoint URI becomes:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;from("cxf:registration?serviceClass=https.www_herongyang_com.service.RegistrationPortType&amp;cxfConfigurer=#mywssecurity")&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;On the other hand, for the client, it becomes:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;to("cxf:http://localhost:8055/soap/registration?serviceClass=https.www_herongyang_com.service.RegistrationPortType&amp;cxfConfigurer=#mywssecurity")&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;On both lines, the &lt;code&gt;mywssecurity&lt;/code&gt; element is a reference to a Java bean that implements the CxfConfigurer interface. This interface has methods to configure either the CXF server, client, or both. Thus, in our case, on the client side, we have:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;@Named("mywssecurity") @ApplicationScoped public class WSServiceBean implements CxfConfigurer { @Inject @ConfigProperty (name = "app.webservice.soap.wssecurity.user") // custom property defined in application.properties private String user; @Inject @ConfigProperty (name = "app.webservice.soap.wssecurity.mustunderstand") // custom property defined in application.properties private String mustunderstand; public WSServiceBean() { super(); } @Override public void configure(AbstractWSDLBasedEndpointFactory factoryBean) { // TODO Auto-generated method stub //throw new UnsupportedOperationException("Unimplemented method 'configure'"); } @Override public void configureClient(Client client) { Map&lt;String,Object&gt; wsproperties = new HashMap&lt;String, Object&gt;(); wsproperties.put(ConfigurationConstants.ACTION, ConfigurationConstants.USERNAME_TOKEN_NO_PASSWORD); wsproperties.put(ConfigurationConstants.ALLOW_USERNAMETOKEN_NOPASSWORD, "true"); wsproperties.put(ConfigurationConstants.USER, user); wsproperties.put(ConfigurationConstants.MUST_UNDERSTAND, mustunderstand); WSS4JOutInterceptor wssecurity = new WSS4JOutInterceptor(wsproperties); client.getOutInterceptors().add(wssecurity); //throw new UnsupportedOperationException("Unimplemented method 'configureClient'"); } @Override public void configureServer(Server server) { // TODO Auto-generated method stub //throw new UnsupportedOperationException("Unimplemented method 'configureServer'"); } }&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;While on the server side, we have the following:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;@Named("mywssecurity") @ApplicationScoped public class WSServiceBean implements CxfConfigurer { @Inject @ConfigProperty (name = "app.webservice.soap.wssecurity.user") // custom property defined in application.properties private String user; public WSServiceBean() { super(); } @Override public void configure(AbstractWSDLBasedEndpointFactory factoryBean) { // TODO Auto-generated method stub //throw new UnsupportedOperationException("Unimplemented method 'configure'"); } @Override public void configureClient(Client client) { // TODO Auto-generated method stub //throw new UnsupportedOperationException("Unimplemented method 'configureClient'"); } @Override public void configureServer(Server server) { Map&lt;String,Object&gt; wsproperties = new HashMap&lt;String, Object&gt;(); wsproperties.put(ConfigurationConstants.ACTION, ConfigurationConstants.USERNAME_TOKEN_NO_PASSWORD); wsproperties.put(ConfigurationConstants.ALLOW_USERNAMETOKEN_NOPASSWORD, "true"); wsproperties.put(ConfigurationConstants.USER, user); WSS4JInInterceptor wssecurity = new WSS4JInInterceptor(wsproperties); server.getEndpoint().getInInterceptors().add(wssecurity); //throw new UnsupportedOperationException("Unimplemented method 'configureClient'"); } }&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Summary&lt;/h2&gt; &lt;p&gt;This article demonstrates how to configure SOAP web services with the Red Hat build of Apache Camel, Quarkus version. If you have questions, feel free to comment below. We welcome your feedback!&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2023/03/28/how-configure-soap-web-services-apache-camel" title="How to configure SOAP web services with Apache Camel"&gt;How to configure SOAP web services with Apache Camel&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Michael Thirion</dc:creator><dc:date>2023-03-28T07:00:00Z</dc:date></entry><entry><title type="html">How to configure CORS on WildFly</title><link rel="alternate" href="http://www.mastertheboss.com/web/jboss-web-server/how-to-configure-cors-on-wildfly/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/web/jboss-web-server/how-to-configure-cors-on-wildfly/</id><updated>2023-03-27T19:57:30Z</updated><content type="html">If you are running your web applications on WildFly, you can configure CORS to allow cross-domain requests. In this article, we will go through the steps to configure CORS on WildFly. What is a Cross Resource Sharing (CORS)? Cross-Origin Resource Sharing (CORS) is a security mechanism that allows web applications to make requests to a ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title type="html">How to tune the performance of Java 11 HttpClients</title><link rel="alternate" href="http://www.mastertheboss.com/java/how-to-tune-the-performance-of-java-11-httpclients/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/java/how-to-tune-the-performance-of-java-11-httpclients/</id><updated>2023-03-27T11:08:41Z</updated><content type="html">The Java 11 HttpClient API provides a lot of configuration options that you can use to tune its performance. In this tutorial, we will explore some of the most important ones. Connection Pooling Connection pooling is a technique that allows you to reuse existing connections instead of creating new ones for each request. This can ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title type="html">Writing high performance Apache HTTP Clients</title><link rel="alternate" href="http://www.mastertheboss.com/java/writing-high-performance-java-http-client-applications/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/java/writing-high-performance-java-http-client-applications/</id><updated>2023-03-27T08:40:59Z</updated><content type="html">When it comes to consuming HTTP resources in Java applications, Apache HTTP Client is a popular choice for developers due to its ease of use, flexibility, and robustness. In this article, we will explore how to write a high-performance Java HTTP client using the Apache HTTP Client library. Disambiguation: This article discusses about the performance ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title>How JBoss EAP 8 Beta simplifies external database config</title><link rel="alternate" href="https://developers.redhat.com/articles/2023/03/27/how-jboss-eap-8-beta-simplifies-external-database-config" /><author><name>Philip Hayes</name></author><id>08d7035a-936e-4355-9d76-e82a77f17ada</id><updated>2023-03-27T07:00:00Z</updated><published>2023-03-27T07:00:00Z</published><summary type="html">&lt;p&gt;In this article, we will demonstrate how to deploy a complex &lt;a href="https://developers.redhat.com/products/eap/overview"&gt;Red Hat JBoss Enterprise Application Platform&lt;/a&gt; application using the &lt;a href="https://github.com/jbossas/eap-datasources-galleon-pack"&gt;datasources feature pack&lt;/a&gt; to deploy the required drivers and configuration to connect to a PostgreSQL database. The datasources feature pack for JBoss Enterprise Application Platform (EAP) and JBoss EAP XP makes it easy to configure JBoss EAP with JDBC drivers and data sources for various databases such as Oracle, Microsoft SQL Server, and PostgreSQL.&lt;/p&gt; &lt;p&gt;This is a follow-up to the previous article &lt;a href="https://developers.redhat.com/articles/2023/02/08/how-jboss-eap-8-beta-makes-deployment-openshift-easier"&gt;How JBoss EAP 8 Beta makes deployment on OpenShift easier&lt;/a&gt;, where we demonstrated provisioning a simple hello world JBoss EAP 8 Beta application for &lt;a href="https://developers.redhat.com/products/openshift/overview"&gt;Red Hat OpenShift&lt;/a&gt; using the &lt;a href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/8-beta/html-single/using_jboss_eap_on_openshift_container_platform/index?extIdCarryOver=true&amp;intcmp=701f20000012k6EAAQ&amp;sc_cid=701f2000001Css5AAC#assembly_provisioning-a-jboss-eap-server-using-the-maven-plugin_assembly_environment-variables-and-model-expression-resolution"&gt;eap-maven-plug-in&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;This article covers the following topics:&lt;/p&gt; &lt;ul&gt;&lt;li aria-level="1"&gt;How to include the Maven configuration necessary to provision and configure a JBoss EAP instance to run our application.&lt;/li&gt; &lt;li aria-level="1"&gt;How to build and deploy the application connecting to a locally running PostgreSQL database.&lt;/li&gt; &lt;li aria-level="1"&gt;How to use Helm charts to build and deploy the application to OpenShift and connect to a PostgreSQL database running on the same cluster.&lt;/li&gt; &lt;/ul&gt;&lt;h2&gt;Set up the prerequisites&lt;/h2&gt; &lt;p&gt;To perform the steps described in this article, you will need the following components.&lt;/p&gt; &lt;ul&gt;&lt;li aria-level="1"&gt;&lt;a href="https://www.redhat.com/en/technologies/cloud-computing/openshift"&gt;OpenShift cluster&lt;/a&gt;. Version 4.11+&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;a href="https://maven.apache.org/download.cgi"&gt;Maven&lt;/a&gt;. Version 3.8.5+&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;a href="https://podman.io/getting-started/installation"&gt;Podman&lt;/a&gt;. Version 4.3.1+ (Docker will also work)&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;a href="https://docs.openshift.com/container-platform/4.12/cli_reference/openshift_cli/getting-started-cli.html"&gt;OpenShift CLI&lt;/a&gt;. Version 4.10+&lt;/li&gt; &lt;/ul&gt;&lt;p&gt;Check out the sample application from this &lt;a href="https://github.com/deewhyweb/eap7-eap8-migration-workshop/tree/main/sample-app-eap8"&gt;GitHub repository&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;Before we start any of our configuration or code changes, we're going to run a PostgreSQL container on our local machine by running the following command in a terminal:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;podman run --name myPostgresDb \    -p 5432:5432 \    -e POSTGRES_USER=postgresUser \    -e POSTGRES_PASSWORD=postgresPW \    -e POSTGRES_DB=postgresDB \    -d postgres&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Step 1: Change the configuration&lt;/h2&gt; &lt;p&gt;To build and deploy this application on OpenShift, the only change we need to make is to the Maven &lt;code&gt;pom.xml&lt;/code&gt; file. This involves adding the eap-maven-plugin, which takes care of all the provisioning and configuration required to build an instance of JBoss EAP 8 Beta to run our application.&lt;/p&gt; &lt;p&gt;It's worth comparing this single step to the multiple steps involved with performing the same task for a JBoss EAP 7 application on OpenShift, as described in the article &lt;a href="https://developers.redhat.com/articles/2022/01/12/how-migrate-your-java-applications-red-hat-openshift#"&gt;How to migrate your Java applications&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;Similarly, to run the application in their local environment for JBoss EAP 7, perform the following steps:&lt;/p&gt; &lt;ul&gt;&lt;li aria-level="1"&gt;Create the .war file (with the mvn package from the project).&lt;/li&gt; &lt;li aria-level="1"&gt;Download JBoss EAP 7.4.&lt;/li&gt; &lt;li aria-level="1"&gt;Download and apply patches to get an updated JBoss EAP 7.4.&lt;/li&gt; &lt;li aria-level="1"&gt;Download the JDBC drivers and put them in the JAR and &lt;code&gt;module.xml&lt;/code&gt; in the server.&lt;/li&gt; &lt;li aria-level="1"&gt;Run CLI commands or edit &lt;code&gt;standalone.xml&lt;/code&gt; to configure the data source.&lt;/li&gt; &lt;li aria-level="1"&gt;Start the server with &lt;code&gt;./standalone.sh&lt;/code&gt;.&lt;/li&gt; &lt;li aria-level="1"&gt;Deploy the application.&lt;/li&gt; &lt;/ul&gt;&lt;p&gt;For JBoss EAP 8, simply run a single Maven command, and the entire process runs.&lt;/p&gt; &lt;p&gt;Let's try this out in our local environment.&lt;/p&gt; &lt;p&gt;Open the &lt;code&gt;pom.xml &lt;/code&gt;file and add the following before the closing tag:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-xml"&gt;   &lt;profile&gt;            &lt;id&gt;openshift&lt;/id&gt;            &lt;build&gt;                &lt;plugins&gt;                    &lt;plugin&gt;                        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                        &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;                        &lt;version&gt;3.3.2&lt;/version&gt;                        &lt;configuration&gt;                            &lt;warName&gt;ROOT&lt;/warName&gt;                            &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;                            &lt;/configuration&gt;                    &lt;/plugin&gt;                    &lt;plugin&gt;                         &lt;groupId&gt;org.jboss.eap.plugins&lt;/groupId&gt;                        &lt;artifactId&gt;eap-maven-plugin&lt;/artifactId&gt;                        &lt;version&gt;1.0.0.Beta6-redhat-00001&lt;/version&gt;                        &lt;configuration&gt;                            &lt;channels&gt;                                &lt;channel&gt;                                    &lt;groupId&gt;org.jboss.eap.channels&lt;/groupId&gt;                                    &lt;artifactId&gt;eap-8.0-beta&lt;/artifactId&gt;                                &lt;/channel&gt;                            &lt;/channels&gt;                            &lt;feature-packs&gt;                                &lt;feature-pack&gt;                                    &lt;location&gt;org.jboss.eap:wildfly-ee-galleon-pack&lt;/location&gt;                                &lt;/feature-pack&gt;                                &lt;feature-pack&gt;                                    &lt;location&gt;org.jboss.eap.cloud:eap-cloud-galleon-pack&lt;/location&gt;                                &lt;/feature-pack&gt;                                &lt;feature-pack&gt;                                    &lt;location&gt;org.jboss.eap:eap-datasources-galleon-pack&lt;/location&gt;                                &lt;/feature-pack&gt;                            &lt;/feature-packs&gt;                            &lt;layers&gt;                                &lt;layer&gt;cloud-server&lt;/layer&gt;                                &lt;layer&gt;postgresql-datasource&lt;/layer&gt;                                &lt;layer&gt;ejb&lt;/layer&gt;                                &lt;layer&gt;jsf&lt;/layer&gt;                            &lt;/layers&gt;                            &lt;filename&gt;ROOT.war&lt;/filename&gt;                        &lt;/configuration&gt;                        &lt;executions&gt;                            &lt;execution&gt;                                &lt;goals&gt;                                    &lt;goal&gt;package&lt;/goal&gt;                                &lt;/goals&gt;                            &lt;/execution&gt;                        &lt;/executions&gt;                    &lt;/plugin&gt;                &lt;/plugins&gt;            &lt;/build&gt;        &lt;/profile&gt;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;If we examine the &lt;code&gt;pom.xml&lt;/code&gt; snippet, we can see the inclusion of three feature packs:&lt;/p&gt; &lt;ul&gt;&lt;li aria-level="1"&gt;&lt;a href="https://docs.wildfly.org/21/Galleon_Guide.html#wildfly_galleon_layers"&gt;&lt;strong&gt;wildfly-ee-galleon-pack&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;:&lt;/strong&gt; The wildfly-ee-galleon-pack contains the features required to build an instance of JBoss EAP. This feature pack contains several layers (e.g., jaxrs-server and cloud-server).&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;a href="https://github.com/wildfly-extras/wildfly-cloud-galleon-pack/blob/main/doc/index.md"&gt;&lt;strong&gt;eap-cloud-galleon-pack&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;:&lt;/strong&gt; You can find &lt;a href="https://github.com/wildfly-extras/wildfly-cloud-galleon-pack/blob/main/doc/index.md"&gt;more information&lt;/a&gt; about this feature pack. The main features are as follows: &lt;ul&gt;&lt;li aria-level="2"&gt;Server startup scripts: When starting an EAP server that was provisioned by the cloud feature-pack, a set of bash scripts are executed in order to adjust the server configuration. These scripts configure a range of server functions such as clustering, security, logging, messaging, tracing, and config management. &lt;a href="https://github.com/wildfly-extras/wildfly-cloud-galleon-pack/blob/main/doc/launch.md"&gt;Read more on this.&lt;/a&gt;&lt;/li&gt; &lt;li aria-level="2"&gt;Adjustment of WildFly Galleon layers to tune for deployment on OpenShift, for example, disabling the management console. &lt;a href="https://github.com/wildfly-extras/wildfly-cloud-galleon-pack/blob/main/doc/layers.md"&gt;Read more on this.&lt;/a&gt;&lt;/li&gt; &lt;li aria-level="2"&gt;Automatic provisioning of the health subsystem allows for server state monitoring and provides liveness and readiness probes.&lt;/li&gt; &lt;li aria-level="2"&gt;Automatic routing of server logs to the console to ensure they are visible in the pod logs in the OpenShift console.&lt;/li&gt; &lt;/ul&gt;&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;a href="https://github.com/jbossas/eap-datasources-galleon-pack"&gt;&lt;strong&gt;eap-datasources-galleon-pack&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;:&lt;/strong&gt; This feature pack for JBoss EAP and &lt;a href="https://catalog.redhat.com/software/container-stacks/detail/5ef65e3d57e317fa624c302a"&gt;JBoss EAP Expansion Pack &lt;/a&gt; provides JDBC drivers and data sources for the following databases:&lt;/li&gt; &lt;/ul&gt;&lt;ul class="Indent2"&gt;&lt;li aria-level="1"&gt;Microsoft SQL Server&lt;/li&gt; &lt;li aria-level="1"&gt;Oracle&lt;/li&gt; &lt;li aria-level="1"&gt;PostgreSQL&lt;/li&gt; &lt;/ul&gt;&lt;p&gt;We can also see the inclusion of four layers in our &lt;code&gt;pom.xml&lt;/code&gt; file snippet:&lt;/p&gt; &lt;ul&gt;&lt;li aria-level="1"&gt;&lt;strong&gt;cloud-server:&lt;/strong&gt; The cloud server layer is an extension of the jaxrs-server and datasources-web-server layers providing cloud-native functionality such as observability and jms-activemq.&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;strong&gt;postgresql-datasource:&lt;/strong&gt; Adds support for postgresql database drivers, requires the eap-datasources-galleon-pack feature pack.&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;strong&gt;ejb:&lt;/strong&gt; Adds support for Jakarta Enterprise Beans, excluding the IIOP protocol.&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;strong&gt;jsf:&lt;/strong&gt; Adds support for Jakarta Server Faces.&lt;/li&gt; &lt;/ul&gt;&lt;p&gt;The addition of datasources feature pack and postgresql-datasource layer will instruct the eap-maven-plugin to install and configure a data source to connect to a PostgreSQL database. If we look at the &lt;a href="https://github.com/jbossas/eap-datasources-galleon-pack/blob/main/doc/postgresql/README.md"&gt;documentation for the PostgresSQL layer&lt;/a&gt;, we can see the need for a &lt;code&gt;POSTGRESQL_DRIVER_VERSION&lt;/code&gt; build time environment variable. This build time environment variable is mandatory and tells the eap-maven-plugin which version of the PostgreSQL driver to install.&lt;/p&gt; &lt;h2&gt;Step 2: Test the application locally&lt;/h2&gt; &lt;p&gt;Once this configuration is added, we can now test our application locally using the eap-maven-plugin to provision a JBoss EAP server. Before we do this, we need to set a few environment variables.&lt;/p&gt; &lt;p&gt;As we mentioned in the previous section, we need to tell the eap-maven-plugin which version of the PostgreSQL driver to install with the &lt;code&gt;POSTGRESQL_DRIVER_VERSION&lt;/code&gt; environment variable.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;export POSTGRESQL_DRIVER_VERSION=42.2.19&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;We can provision our local instance of JBoss EAP with the required feature pack and layers with the following command:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;mvn clean package -Popenshift&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This command does many things, such as:&lt;/p&gt; &lt;ul&gt;&lt;li aria-level="1"&gt;Build the &lt;a href="https://developers.redhat.com/java"&gt;Java&lt;/a&gt; application.&lt;/li&gt; &lt;li aria-level="1"&gt;Provision a JBoss EAP server with all the capabilities that the application requires.&lt;/li&gt; &lt;li aria-level="1"&gt;Deploy the application in the server.&lt;/li&gt; &lt;/ul&gt;&lt;p&gt;You can then run the application from the &lt;code&gt;./target/server&lt;/code&gt; folder because the build artifact is already deployed to the server. This is a big difference from the JBoss EAP 7 workflow, where users have to package their app and then deploy it in a running JBoss EAP.&lt;/p&gt; &lt;p&gt;Before we start our JBoss EAP instance, we will need runtime environment variables to configure the connection to our local instance of PostgreSQL. These should match the variables passed to our PostgreSQL container by our &lt;code&gt;podman run&lt;/code&gt; command from the prerequisites section:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;export POSTGRESQL_DATABASE=postgresDB \ &amp;&amp; export POSTGRESQL_USER=postgresUser \ &amp;&amp; export POSTGRESQL_PASSWORD=postgresPW \ &amp;&amp; export POSTGRESQL_DATASOURCE=postgresql \ &amp;&amp; export POSTGRESQL_SERVICE_HOST=127.0.0.1 &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;We can now run our application deployed in JBoss EAP with the following command:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;./target/server/bin/standalone.sh&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Then open our browser at http://127.0.0.1:8080. We should see a UI, as shown in Figure 1.&lt;/p&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/kitchensink_1.jpg" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/kitchensink_1.jpg?itok=QXgRPnI6" width="600" height="358" alt="Screenshot of kitchensink application running on localhost." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 1: The kitchensink application running on localhost.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;p&gt;Now that we have successfully configured our application and deployed a local instance, we can test what will be provisioned during the OpenShift Source-to-Image (&lt;a href="https://docs.openshift.com/container-platform/4.12/openshift_images/using_images/using-s21-images.html"&gt;S2I&lt;/a&gt;) build process when deploying our application to OpenShift.&lt;/p&gt; &lt;h2&gt;Step 3: Build and deploy on OpenShift&lt;/h2&gt; &lt;p&gt;Before we start the build process on OpenShift, we will need a PostgreSQL database. Follow these steps:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;Log in to the OpenShift console.&lt;/li&gt; &lt;li&gt;From the developer UI, click on &lt;strong&gt;Add&lt;/strong&gt;.&lt;/li&gt; &lt;li&gt;Select &lt;strong&gt;Database&lt;/strong&gt; from the developer catalog.&lt;/li&gt; &lt;li&gt;Choose &lt;strong&gt;PostgreSQL (Ephemeral)&lt;/strong&gt;, as shown in Figure 2.&lt;/li&gt; &lt;/ul&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/create_database.jpg" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/create_database.jpg?itok=ENL1AQMB" width="600" height="306" alt="OpenShift database catalog" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 2: OpenShift database catalog.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;ul&gt;&lt;li&gt;Click on &lt;strong&gt;Instantiate Template&lt;/strong&gt; and populate the resulting form as shown in Figure 3.&lt;/li&gt; &lt;/ul&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/instantiate_template.jpg" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/instantiate_template.jpg?itok=Q9iAfQ9k" width="600" height="342" alt="The PostgreSQL template form." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 3: Complete the PostgreSQL template form.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;ul&gt;&lt;li&gt;For reference, the two field values we're changing are: &lt;ul&gt;&lt;li&gt;&lt;strong&gt;Database Service Name:&lt;/strong&gt; &lt;code&gt;eap-sample-db&lt;/code&gt;&lt;/li&gt; &lt;li&gt;&lt;strong&gt;PostgreSQL Database Name: &lt;/strong&gt;&lt;code&gt;sample-db&lt;/code&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/li&gt; &lt;li&gt;Click on &lt;strong&gt;Create&lt;/strong&gt; to create the PostgreSQL database instance.&lt;/li&gt; &lt;li&gt;We can now deploy our EAP 8 Beta application with Helm.&lt;/li&gt; &lt;li&gt;Click on &lt;strong&gt;Add+&lt;/strong&gt;.&lt;/li&gt; &lt;li&gt;Select &lt;strong&gt;Helm Chart&lt;/strong&gt; from the developer catalog.&lt;/li&gt; &lt;li&gt;Enter &lt;strong&gt;eap8&lt;/strong&gt; in the &lt;strong&gt;Filter by keyword&lt;/strong&gt; field as shown in Figure 4.&lt;/li&gt; &lt;/ul&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/select_helm.jpg" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/select_helm.jpg?itok=CkK6CXaA" width="600" height="218" alt="Select the JBoss EAP 8 Helm chart from the catalog." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 4: Select the JBoss EAP 8 Helm chart from the catalog.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;p class="Indent1"&gt;&lt;strong&gt;Note:&lt;/strong&gt; For the purpose of this article, we've already created a version of this application with the eap-maven-plug configuration added to the &lt;code&gt;pom.xml&lt;/code&gt; file. In the next step, we'll reference this version in the &lt;code&gt;sample-app-eap8-ocp&lt;/code&gt; folder.&lt;/p&gt; &lt;ul&gt;&lt;li&gt;Select &lt;strong&gt;Eap8&lt;/strong&gt;.&lt;/li&gt; &lt;li&gt;Click on &lt;strong&gt;Install Helm Chart&lt;/strong&gt;.&lt;/li&gt; &lt;li&gt;Switch to YAML view.&lt;/li&gt; &lt;li&gt;Delete the existing content.&lt;/li&gt; &lt;li&gt;Paste the following YAML:&lt;/li&gt; &lt;/ul&gt;&lt;pre&gt; &lt;code class="language-yaml"&gt;build:  uri: https://github.com/deewhyweb/eap7-eap8-migration-workshop.git  ref: main  contextDir: sample-app-eap8-ocp  env:    - name: POSTGRESQL_DRIVER_VERSION      value: '42.5.1' deploy:  replicas: 1  env:    # Env vars to connect to PostgreSQL DB    - name: POSTGRESQL_DATABASE      valueFrom:        secretKeyRef:          key: database-name          name: eap-sample-db    - name: POSTGRESQL_USER      valueFrom:        secretKeyRef:          key: database-user          name: eap-sample-db    - name: POSTGRESQL_PASSWORD      valueFrom:        secretKeyRef:          key: database-password          name: eap-sample-db    - name: POSTGRESQL_DATASOURCE      value: postgresql    - name: POSTGRESQL_SERVICE_HOST      value: eap-sample-db&lt;/code&gt;&lt;/pre&gt; &lt;p class="Indent1"&gt;&lt;strong&gt;Note:&lt;/strong&gt; There are a few things to point out in this Helm configuration. We have defined a build time variable &lt;code&gt;POSTGRESQL_DRIVER_VERSION&lt;/code&gt; to determine how the PostgreSQL driver version is passed to the eap-maven-plugin when S2I builds the application image. Runtime environment variables (such as user credentials) are read from a secret created when the database is instantiated. So application configuration can be safely stored in Git without any sensitive information.&lt;/p&gt; &lt;ul&gt;&lt;li&gt;Click on &lt;strong&gt;Install&lt;/strong&gt; and you will be taken to the topology view, as shown in Figure 5.&lt;/li&gt; &lt;/ul&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/topology.jpg" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/topology.jpg?itok=TcuyGToC" width="600" height="475" alt="OpenShift topology view" typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt;&lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt;Figure 5: OpenShift topology view.&lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;p&gt;Two build-configs are created by this Helm chart: an artifacts build and a runtime build. When the second build is complete, the application will be deployed. The application is running when the pod donut around the JBoss EAP logo is dark blue (i.e., the pods are in a running state).&lt;/p&gt; &lt;p&gt;It will take a while to build and deploy the application. To monitor the progress, follow these steps.&lt;/p&gt; &lt;ul&gt;&lt;li&gt;Go to &lt;strong&gt;Builds&lt;/strong&gt;. &lt;/li&gt; &lt;li&gt;Select &lt;strong&gt;eap8-build-artifacts&lt;/strong&gt;.&lt;/li&gt; &lt;li&gt;Choose the &lt;strong&gt;Builds&lt;/strong&gt; tab.&lt;/li&gt; &lt;li&gt;Click on &lt;strong&gt;eap8-build-artifacts-1&lt;/strong&gt; to view the logs of the active build.&lt;/li&gt; &lt;li&gt;Once the builds are complete, you will be able to click the &lt;strong&gt;Open URL&lt;/strong&gt; icon of the &lt;strong&gt;eap8&lt;/strong&gt; deployment to view the running application.&lt;/li&gt; &lt;/ul&gt;&lt;h2&gt;A simple configuration&lt;/h2&gt; &lt;p&gt;In this article, we added the eap-maven-plugin to an existing JBoss EAP 8-Beta project to enable the provisioning of a JBoss EAP instance, including integration to a PostgreSQL database. Then we used the JBoss EAP 8 Helm chart to build and deploy this image on OpenShift.&lt;/p&gt; &lt;p&gt;The data sources feature pack for JBoss EAP and JBoss EAP XP makes it easy to configure JBoss EAP with JDBC drivers and data sources for various databases. The developer experience for local development and OpenShift configuration has also improved, making it far easier to set up a local environment and ensure successful deployment on OpenShift.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2023/03/27/how-jboss-eap-8-beta-simplifies-external-database-config" title="How JBoss EAP 8 Beta simplifies external database config"&gt;How JBoss EAP 8 Beta simplifies external database config&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Philip Hayes</dc:creator><dc:date>2023-03-27T07:00:00Z</dc:date></entry><entry><title type="html">Keycloak OpenID Authentication with WildFly</title><link rel="alternate" href="http://www.mastertheboss.com/keycloak/keycloak-oauth2-example-with-rest-application/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/keycloak/keycloak-oauth2-example-with-rest-application/</id><updated>2023-03-26T18:21:57Z</updated><content type="html">Keycloak is an open-source identity and access management solution that supports OpenID Connect and OAuth 2.0 protocols. In this tutorial we will learn how to configure a Keycloak Realm and use as OpenID Client an application running on WildFly. Before we get started, we need to learn some terms we will use in this article: ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title type="html">Managing Keycloak user metadata and custom attributes</title><link rel="alternate" href="http://www.mastertheboss.com/keycloak/managing-keycloak-user-metadata-and-custom-attributes/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/keycloak/managing-keycloak-user-metadata-and-custom-attributes/</id><updated>2023-03-26T14:10:10Z</updated><content type="html">Each user that is stored in Keycloak can store basic Metadata information such as name and email. Besides that, you can store arbitrary user attributes, also called Custom Attributes. In this tutorial, we will show an example application which retrieves User Metadata and Custom Attributes for a Keycloak Realm. This tutorial assumes that you are ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title type="html">Developing with IntelliJ Idea and WildFly</title><link rel="alternate" href="http://www.mastertheboss.com/eclipse/intellij-idea/developing-applications-with-intellij-idea-and-wildfly/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/eclipse/intellij-idea/developing-applications-with-intellij-idea-and-wildfly/</id><updated>2023-03-26T13:29:46Z</updated><content type="html">This tutorial will give you an headstart about developing Enterprise applications with IntelliJ IDEA and WildFly. We will cover how to manage the integration with the application server and how to debug applications. Developing applications with IntelliJ Idea and WildFly is a popular choice for many Java developers. IntelliJ Idea is a powerful integrated development environment ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title type="html">Examples of jboss-deployment-structure.xml</title><link rel="alternate" href="http://www.mastertheboss.com/jbossas/jboss-deploy/practical-examples-of-jboss-deployment-structure-xml/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/jbossas/jboss-deploy/practical-examples-of-jboss-deployment-structure-xml/</id><updated>2023-03-26T10:29:15Z</updated><content type="html">This tutorial contains some examples of how to configure the file jboss-deployment-structure.xml . This file allows to fine tune the modules of your applications running on WildFly. The advantage of using this file (compared to the Manifest’s entry) is that you can define dependencies across top-level deployments and subdeployments. Basic sample of jboss-deployment-structure.xml Here is ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title type="html">Choosing the right JDK for WildFly and JBoss EAP 7</title><link rel="alternate" href="http://www.mastertheboss.com/jbossas/wildfly-8/choosing-the-jdk-for-wildfly-and-jboss-eap-7/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/jbossas/wildfly-8/choosing-the-jdk-for-wildfly-and-jboss-eap-7/</id><updated>2023-03-26T09:50:06Z</updated><content type="html">This tutorial discusses the recommended JDK versions to be used for WildFly and JBoss Enterprise Application Platform (EAP) and how to set the Java version for it. The modularization of the JVM that began with Java 9 had a significant impact on a complex server like WildFly, particularly in the areas of classloading and reflection, ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry></feed>
